#+TITLE: dogenpunk .emacs.el file
#+EMAIL: dogenpunk@gmail.com
#+STARTUP:  odd hidestarts fold
#+OPTIONS:  skip:nil toc:nil
#+PROPERTY: header-args :tangle ~/.emacs.el :comments both

This is my =.emacs.el= file written in =org-mode=. There are many like it,
but this one is mine...

* Emacs start time
Tracking Emacs' start time is more of a curiosity to me rather than a
metric I obsess over. Using =lexical-let= from the forever controversial
=cl= package allows me to keep this code all together rather than having
to split it between the start and end of the file.
#+begin_src emacs-lisp
  (eval-when-compile (require 'cl))

  (lexical-let ((emacs-start-time (current-time)))
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((elapsed (float-time (time-subtract (current-time) emacs-start-time))))
                  (message "[Emacs initialized in %.3fs]" elapsed)))))
#+end_src

** Tweek garbage collection
#+begin_src emacs-lisp
  (lexical-let ((old-gc-cons-threshold gc-cons-threshold))
    (setq gc-cons-threshold (* 256 1024 1024))
    (add-hook 'emacs-startup-hook
              (lambda ()
                (setq gc-cons-threshold old-gc-cons-threshold))))

  (add-hook 'focus-out-hook 'garbage-collect)
#+end_src

* Custom file
#+begin_src emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src
* Package Initialization
#+begin_src emacs-lisp
  (require 'gnutls)
  (add-to-list 'gnutls-trustfiles "/usr/local/etc/openssl/cert.pem")

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org"   . "https://orgmode.org/elpa/")
                           ("gnu"   . "https://elpa.gnu.org/packages/")))

  (setq package-enable-at-startup nil)
  (package-initialize)
#+end_src

* Package and file loading
** Load path
#+begin_src emacs-lisp
  (let ((base (concat user-emacs-directory "elisp/")))
    (add-to-list 'load-path base)
    (dolist (dir (directory-files base t "^[^.]"))
      (when (file-directory-p dir)
        (add-to-list 'load-path dir))))
#+end_src
** Measure load

#+begin_src emacs-lisp
  (defmacro /boot/measure-load (target &rest body)
    (declare (indent defun))
    `(let ((elapsed)
           (start (current-time)))
       (prog1
           ,@body
         (with-current-buffer (get-buffer-create "*Load Times*")
           (when (= 0 (buffer-size))
             (insert (format "| %-60s | %-23s | elapsed |\n" "feature" "timestamp"))
             (insert "|------------------------------------------+-------------------------+----------|\n"))
           (goto-char (point-max))
           (setq elapsed (float-time (time-subtract (current-time) start)))
           (insert (format "| %-60s | %s | %f |\n"
                           ,target
                           (format-time-string "%Y-%m-%d %H:%M:%S.%3N" (current-time))
                           elapsed))))))

  (defadvice load (around dotemacs activate)
    (/boot/measure-load file ad-do-it))

  (defadvice require (around dotemacs activate)
    (if (memq feature features)
        ad-do-it
      (/boot/measure-load feature ad-do-it)))
#+end_src

** Require package

#+begin_src emacs-lisp
  (defun require-package (package)
    "Ensures that PACKAGE is installed."
    (unless (or (package-installed-p package)
                (require package nil 'noerror))
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))
#+end_src

** `After' macro

#+begin_src emacs-lisp
  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded."
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+end_src

** After Load
   #+begin_src emacs-lisp
     (if (fboundp 'with-eval-after-load)
         (defalias 'after-load 'with-eval-after-load)
       (defmacro after-load (feature &rest body)
         "After FEATURE is loaded, evaluate BODY."
         (declare (indent defun))
         `(eval-after-load ,feature
            '(progn ,@body))))
   #+end_src
** Lazy major mode

#+begin_src emacs-lisp
  (defmacro /boot/lazy-major-mode (pattern mode)
    "Defines a new major-mode matched by PATTERN, installs MODE if necessary, and activates it."
    `(add-to-list 'auto-mode-alist
                  '(,pattern . (lambda ()
                                 (require-package (quote ,mode))
                                 (,mode)))))
#+end_src

** Delayed init

#+begin_src emacs-lisp
  (defmacro /boot/delayed-init (&rest body)
    "Runs BODY after idle for a predetermined amount of time."
    `(run-with-idle-timer
      0.5
      nil
      (lambda () ,@body)))
#+end_src

* UI
#+begin_src emacs-lisp
  (line-number-mode t)
  (column-number-mode t)
  (display-time-mode t)
  (size-indication-mode t)

  ;; (set-frame-font "Input-11")
  ;; (set-frame-font "Anonymous-Pro-11")
  ;; (set-frame-font "Fira Code Medium 12")

  (defun my/font-exists-p (font)
    "Checks if the named FONT exists on the current system."
    (let ((spec (font-spec :name font)))
      (find-font spec)))

  (cond       ((my/font-exists-p "Hack") (set-frame-font "Hack 10" t t))
              ((my/font-exists-p "Fira Code") (set-frame-font "Fira Code Medium 10" t t))
              ((my/font-exists-p "Input") (set-frame-font "Input 10" t t))
              ((my/font-exists-p "Source Code Pro") (set-frame-font "Source Code Pro Light 10" t t))
              ((my/font-exists-p "Anonymous Pro") (set-frame-font "Anonymous Pro 10" t t)))

  (setq display-time-default-load-average nil)

  (require-package 'fill-column-indicator)
  (fci-mode)

  ;; Whitespace
  (require-package 'whitespace)
  (setq whitespace-line-column 79)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  (require-package 'origami)
  (global-origami-mode)

  (require-package 'diminish)
  (diminish 'visual-line-mode)
  (after 'aggressive-indent (diminish 'aggressive-indent-mode))
  (after 'autorevert (diminish #'auto-revert-mode))
  (after 'company (diminish 'company-mode))
  (after 'counsel (diminish #'counsel-mode))
  (after 'eldoc (diminish 'eldoc-mode))
  (after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
  (after 'flycheck (diminish 'flycheck-mode))
  (after 'ivy (diminish 'ivy-mode))
  (after 'smartparens (diminish 'smartparens-mode))
  (after 'which-key (diminish 'which-key-mode))
  (after 'highlight-symbol (diminish 'highlight-symbol-mode))

  (require-package 'smart-mode-line)
  (sml/setup)

  (when (and (display-graphic-p)
             (font-info "all-the-icons"))
    (setq all-the-icons-scale-factor 0.7)
    (setq inhibit-compacting-font-caches t)

    (after 'dired
      (require-package 'all-the-icons-dired)
      (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

    (after 'ivy
      (require-package 'all-the-icons-ivy)
      (all-the-icons-ivy-setup)))

  (global-hl-line-mode)


  (winner-mode t)
  (require-package 'rainbow-delimiters)
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)

  (require-package 'highlight-symbol)
  (setq highlight-symbol-idle-delay 0.3)
  (add-hook 'prog-mode-hook 'highlight-symbol-mode)

  (require-package 'highlight-quoted)
  (add-hook 'prog-mode-hook 'highlight-quoted-mode)

  ;; Themes
  ;; https://www.greghendershott.com/2017/02/emacs-themes.html
  (defvar /config/theme-hooks nil
    "((theme-id . function) ...)")

  (defun /config/add-theme-hook (theme-id hook-fn)
    (add-to-list '/config/theme-hooks (cons theme-id hook-fn)))

  (defun /config/disable-themes ()
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))

  (defun /config/load-theme-advice (f theme-id &optional no-confirm no-enable &rest args)
    "Enhances `load-theme' in two ways:
  1. Disables enabled themes for a clean slate.
  2. Calls functions registered using `/config/add-theme-hook'."
    (unless no-enable
      (/config/disable-themes))
    (prog1
        (apply f theme-id no-confirm no-enable args)
      (unless no-enable
        (pcase (assq theme-id /config/theme-hooks)
          (`(,_ . ,f) (funcall f))))))

  (advice-add 'load-theme
              :around
              #'/config/load-theme-advice)

  ;; (load-theme 'gruvbox-dark-hard)
  (load-theme 'nimbus)

  ;;
  (require-package 'beacon)
  (beacon-mode 1)
  (setq beacon-blink-when-buffer-changes t)
  (setq beacon-blink-when-window-scrolls t)
  (setq beacon-blink-when-window-changes t)
  (setq beacon-blink-when-focused t)

  (setq beacon-blink-duration 0.3)
  (setq beacon-blink-delay 0.3)
  (setq beacon-size 20)
  (setq beacon-color "yellow")

  (add-to-list 'beacon-dont-blink-major-modes 'term-mode)


  ;; Dashboard
  (require-package 'dashboard)
  (require 'dashboard)
  (dashboard-setup-startup-hook)

  (setq dashboard-items '((recents . 5)
                          (bookmarks . 5)
                          (projects . 5)
                          (agenda . 5)
                          (registers . 5)))

  (mouse-avoidance-mode 'cat-and-mouse)

  (setq fill-column 72)
  (setq visible-bell t)
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (when (display-graphic-p) (menu-bar-mode -1))

  (defun /ui/add-prog-mode-watchwords ()
    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|TODO\\|HACK\\|REFACTOR\\|NOCOMMIT\\)"
        1 font-lock-warning-face t))))
  (add-hook 'prog-mode-hook #'/ui/add-prog-mode-watchwords)
#+end_src

* Core
#+begin_src emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))

  (require 'recentf)
  (setq recentf-save-file (concat user-emacs-directory "recentf"))
  (setq recentf-max-saved-items 1000)
  (setq recentf-max-menu-items 500)
  (setq recentf-auto-cleanup 300)
  (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")
  (add-to-list 'recentf-exclude ".*elpa.*autoloads\.el$")
  (recentf-mode t)
  (run-with-idle-timer 600 t #'recentf-save-list)

  ;; GC
  (defun /core/minibuffer-setup-hook () (setq gc-cons-threshold most-positive-fixnum))
  (defun /core/minibuffer-exit-hook () (setq gc-cons-threshold (* 64 1024 1024)))
  (add-hook 'minibuffer-setup-hook #'/core/minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'/core/minibuffer-exit-hook)

  ;; pcomplete
  (setq pcomplete-ignore-case t)

  ;; imenu
  (setq-default imenu-auto-rescan t)

  ;; narrowing
  (put 'narrow-to-region 'disabled nil)

  ;; dired
  (after 'dired
    (require 'dired-x))

  (setq insert-directory-program "gls")
  (setq dired-use-ls-dired t)

  ;; comint
  (after 'comint
    (defun /core/toggle-comint-scroll-to-bottom-on-output ()
      (interactive)
      (if comint-scroll-to-bottom-on-output
          (setq comint-scroll-to-bottom-on-output nil)
        (setq comint-scroll-to-bottom-on-output t))))

  ;; compile
  (setq compilation-always-kill t)
  (setq compilation-ask-about-save nil)
  (add-hook 'compilation-filter-hook
            (lambda ()
              (when (eq major-mode 'compilation-mode)
                (require 'ansi-color)
                (let ((inhibit-read-only t))
                  (ansi-color-apply-on-region (point-min) (point-max))))))

  ;; bookmarks
  (setq bookmark-default-file (concat user-emacs-directory "bookmarks"))
  (setq bookmark-save-flag 1)

  ;; ediff
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; re-builder
  (setq reb-re-syntax 'string)

  ;; clean up old buffers periodically
  (midnight-mode)
  (midnight-delay-set 'midnight-delay 0)

  ;; ibuffer
  (setq ibuffer-expert nil)
  (setq ibuffer-show-empty-filter-groups t)
  (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode)

  ;; auto-save
  (let ((dir (expand-file-name (concat user-emacs-directory "auto-save/"))))
    (setq auto-save-list-file-prefix (concat dir "saves-"))
    (setq auto-save-file-name-transforms `((".*" ,(concat dir "save-") t))))

  ;; backups
  (setq backup-directory-alist `((".*" . ,(expand-file-name (concat user-emacs-directory "backups/")))))
  (setq backup-by-copying t)
  (setq version-control t)
  (setq kept-old-versions 1000)
  (setq kept-new-versions 50)
  (setq delete-old-versions t)

  ;; scrolling
  (setq scroll-conservatively 9999
        scroll-perserve-screen-position t
        scroll-margin 3)

  ;; unique buffer names
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"
        uniquify-ignore-buffers-re "^\\*"
        uniquify-after-fill-buffer-p t)

  (defun /core/do-not-kill-scratch-buffer ()
    (if (member (buffer-name (current-buffer))
                '("*scratch*" "*Messages*" "*Require Times*"))
        (progn
          (bury-buffer)
          nil)
      t))
  (add-hook 'kill-buffer-query-functions '/core/do-not-kill-scratch-buffer)

  (defalias 'yes-or-no-p 'y-or-n-p)

  (let ((coding 'utf-8-unix))
    (setq locale-coding-system coding)
    (set-selection-coding-system coding)
    (set-default-coding-systems coding)
    (prefer-coding-system coding)
    (setq-default buffer-file-coding-system coding))
  (set-language-environment "UTF-8")

  (setq sentence-end-double-space nil)
  (setq delete-by-moving-to-trash t)
  (setq ring-bell-function 'ignore)
  (setq mark-ring-max 64)
  (setq global-mark-ring-max 128)
  (setq save-interprogram-paste-before-kill t)
  (setq create-lockfiles nil)
  (setq echo-keystrokes 0.01)
  (setq initial-major-mode 'org-mode)
  (setq eval-expression-print-level nil)
  (setq-default indent-tabs-mode nil)
  (setq tab-width 2)
  (setq-default tab-always-indent 'complete)

  (setq inhibit-spash-screen t)
  (setq inhibit-startup-echo-area-message t)

  (global-visual-line-mode)
  (which-function-mode t)
  (blink-cursor-mode -1)
  (global-auto-revert-mode t)
  (electric-indent-mode t)
  (transient-mark-mode t)
  (delete-selection-mode t)
  (random t)

  (defun /core/find-file-hook ()
    (when (string-match "\\.min\\." (buffer-file-name))
      (fundamental-mode)))
  (add-hook 'find-file-hook #'/core/find-file-hook)

  (require-package 'elisp-demos)
  (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1)

  (setq user-full-name "Matthew M. Nelson")
  (setq user-mail-address "dogenpunk@gmail.com")

  ;; Display a backtrace when errors occur
  (setq debug-on-error t)

  ;; Display byte-compiler warnings on error
  (setq byte-compile-debug t)

  (setq scroll-error-top-bottom t)

  (defcustom dotemacs-globally-ignored-directories
    '("elpa" ".cache" "target" "dist" "node_modules" ".git" ".hg" ".svn" ".idea")
    "A set of default directories to ignore for anything that involves searching."
    :type '(repeat string)
    :group 'dotemacs)

  (setq-default help-window-select t)
  (setq create-lockfiles nil)
#+end_src

* Elisp

#+begin_src emacs-lisp
(setq elp-sort-by-function 'elp-sort-by-average-time)
#+end_src

* Key bindings

** Quickly define shortcuts

#+begin_src emacs-lisp
  (defvar my/refile-map (make-sparse-keymap))
  (defmacro my/defshortcut (key file)
    `(progn
       (set-register ,key (cons 'file ,file))
       (define-key my/refile-map
         (char-to-string ,key)
         (lambda (prefix)
           (interactive "p")
           (let((org-refile-targets '(((,file) :maxlevel . 6)))
                (current-prefix-arg (org current-prefix-arg '(4))))
             (call-interactively 'org-refile))))))

#+end_src

** Registers

#+begin_src emacs-lisp
  (set-register ?i (cons 'file (expand-file-name "emacs.org" user-emacs-directory)))
  (my/defshortcut ?j "~/org/journal.org")
  (my/defshortcut ?b "~/org/blog.org")
  (my/defshortcut ?l "~/org/all-posts.org")
  (my/defshortcut ?s "~/org/school.org")
  (my/defshortcut ?g "~/org/goals.org")
  (my/defshortcut ?n "~/org/inbox.org")
  (my/defshortcut ?f "~/org/freelancing.org")
  (my/defshortcut ?e "~/Documents/School")
  (my/defshortcut ?w "~/Workspace/consulting")
#+end_src

** Mac specific key bindings

#+begin_src emacs-lisp
  (setq mac-option-modifier nil)
  (setq mac-command-modifier 'meta)
#+end_src

** Which Key

#+begin_src emacs-lisp
  (require-package 'which-key)
  (setq which-key-idle-delay 0.2)
  (setq which-key-min-display-lines 3)
  (which-key-mode)

#+end_src

** Hippie expand

#+begin_src emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** ibuffer

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

** Searching in buffer

I find it's quicker and easier to use regexp-aware searches within a buffer.

#+begin_src emacs-lisp
(global-set-key (kbd "C-s") 'isearch-forward-regexp)
(global-set-key (kbd "C-r") 'isearch-backward-regexp)
(global-set-key (kbd "C-M-s") 'isearch-forward)
(global-set-key (kbd "C-M-r") 'isearch-backward)
#+end_src

** Cleanup buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c n") '/utils/cleanup-buffer)
#+end_src
** Smart open line

#+begin_src emacs-lisp
  (defun smart-open-line-above ()
    "Insert an empty line above the current line.
  Position the cursor at it's beginning, according to the current mode."
    (interactive)
    (move-beginning-of-line nil)
    (newline-and-indent)
    (forward-line -1)
    (indent-according-to-mode))

  (defun smart-open-line ()
    "Insert an empty line after the current line.
  Position the cursor at it's beginning, according to the current mode."
    (interactive)
    (move-end-of-line nil)
    (newline-and-indent))

  (global-set-key (kbd "M-o") 'smart-open-line)
  (global-set-key (kbd "M-O") 'smart-open-line-above)
#+end_src

** Find things fast!!!

I haven't really started using ftf, but my intuition tells me it could
be useful once I figure out how to fit it into my workflow.

#+begin_src emacs-lisp
  (require-package 'find-things-fast)
  (global-set-key (kbd "<f1>") 'ftf-find-file)
  (global-set-key (kbd "<f2>") 'ftf-grepsource)
  (global-set-key (kbd "<f3>") 'ftf-compile)
#+end_src

** Keying statistics

Much like =find-things-fast=, this isn't something I've integrated yet.

#+begin_src emacs-lisp
  (require-package 'keyfreq)
  (keyfreq-mode 1)
  (setq keyfreq-file (expand-file-name "emacs.keyfreq" user-emacs-directory))
  (keyfreq-autosave-mode 1)
#+end_src

** Global org keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c b") 'org-switchb)
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

** Quickly switch to other window

Quite frequently, I have one Emacs frame split once or twice. A simple
optimization is having a single keystroke to switch between windows
rather than the more common =C-x o= (although, my muscle memory falls
back to that one quite often).

#+begin_src emacs-lisp
(global-set-key (kbd "<f7>") 'other-window)
(global-set-key (kbd "<C-f7>") (lambda () (interactive) (other-window -1)))
#+end_src

** Make narrow or widen DWIM

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
  "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
intelligently.means: region, subtree, or defun, whichever applies
first.

With prefix `P', don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode) (org-narrow-to-subtree))
        (t (narrow-to-defun))))

(global-set-key (kbd "C-x n x") 'narrow-or-widen-dwim)
#+end_src

** Code folding

#+begin_src emacs-lisp
  (require-package 'origami)
  (define-key origami-mode-map (kbd "M-m t") 'origami-toggle-node)
  (define-key origami-mode-map (kbd "M-m a") 'origami-toggle-all-nodes)
#+end_src
** Mode/app specific keybindings

*** Magit

#+begin_src emacs-lisp
(global-set-key (kbd "C-x g") 'magit-status)
#+end_src

*** Speedbar

#+begin_src emacs-lisp
(global-set-key [f11] 'speedbar)
#+end_src

*** Company completion

#+begin_src emacs-lisp
  (after 'company
    (define-key company-active-map (kbd "<tab>") #'company-select-next)
    (define-key company-active-map (kbd "<backtab>") #'company-select-previous)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    (define-key company-active-map (kbd "C-n") #'company-select-next))

#+end_src

*** Dired

#+begin_src emacs-lisp
(global-set-key (kbd "C-~") (lambda () (interactive) (dired "~")))
(global-set-key (kbd "C-c f d") 'find-name-dired)
(global-set-key (kbd "C-c g") 'grep-find)
#+end_src
* Smartparens
#+begin_src emacs-lisp
  (require-package 'smartparens)
  (require 'smartparens-config)

  (defun /config/smartparens-enable-hook ()
    (smartparens-strict-mode)
    (show-smartparens-mode)
    (electric-pair-mode -1))

  (add-hook 'emacs-lisp-mode-hook #'/config/smartparens-enable-hook)
  (add-hook 'lisp-interaction-mode-hook #'/config/smartparens-enable-hook)
  (add-hook 'clojure-mode-hook #'/config/smartparens-enable-hook)
  (add-hook 'cider-mode-hook #'/config/smartparens-enable-hook)
  (add-hook 'cider-repl-mode-hook #'/config/smartparens-enable-hook)

  (electric-pair-mode -1)

  (setq sp-autoinsert-quote-if-followed-by-closing-pair nil)
  (setq sp-autoinsert-pair t)

  (setq sp-show-pair-delay 0)
  (setq sp-show-pair-from-inside t)

  (let ((map smartparens-mode-map))
    ;; Movement and navigation
    (define-key map (kbd "C-M-f") #'sp-forward-sexp)
    (define-key map (kbd "C-M-b") #'sp-backward-sexp)
    (define-key map (kbd "C-M-u") #'sp-backward-up-sexp)
    (define-key map (kbd "C-M-d") #'sp-down-sexp)
    (define-key map (kbd "C-M-p") #'sp-backward-down-sexp)
    (define-key map (kbd "C-M-n") #'sp-up-sexp)
    ;; Deleting and killing
    (define-key map (kbd "C-M-k") #'sp-kill-sexp)
    (define-key map (kbd "C-M-w") #'sp-copy-sexp)
    ;; Depth changing
    (define-key map (kbd "M-s") #'sp-splice-sexp)
    (define-key map (kbd "M-<up>") #'sp-splice-sexp-killing-backward)
    (define-key map (kbd "M-<down>") #'sp-splice-sexp-killing-forward)
    (define-key map (kbd "M-r") #'sp-splice-sexp-killing-around)
    (define-key map (kbd "M-?") #'sp-convolute-sexp)
    ;; Barfage & Slurpage
    (define-key map (kbd "C-)")  #'sp-forward-slurp-sexp)
    (define-key map (kbd "C-<right>") #'sp-forward-slurp-sexp)
    (define-key map (kbd "C-}")  #'sp-forward-barf-sexp)
    (define-key map (kbd "C-<left>") #'sp-forward-barf-sexp)
    (define-key map (kbd "C-(")  #'sp-backward-slurp-sexp)
    (define-key map (kbd "C-M-<left>") #'sp-backward-slurp-sexp)
    (define-key map (kbd "C-{")  #'sp-backward-barf-sexp)
    (define-key map (kbd "C-M-<right>") #'sp-backward-barf-sexp)
    ;; Miscellaneous commands
    (define-key map (kbd "M-S") #'sp-split-sexp)
    (define-key map (kbd "M-J") #'sp-join-sexp)
    (define-key map (kbd "C-M-t") #'sp-transpose-sexp))

  ;; Some additional bindings for strict mode
  (let ((map smartparens-strict-mode-map))
    (define-key map (kbd "M-q") #'sp-indent-defun)
    (define-key map (kbd "C-j") #'sp-newline))

  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
  (sp-with-modes '(html-mode sgml-mode web-mode)
    (sp-local-pair "<" ">"))
#+end_src

* Clojure

I waffle between =cider= and =inf-clojure= mode a lot. =cider= has often
been difficult to setup in the past. Currently, things work mostly
right (aside from controlling which version of Java is used to run
commands).

#+begin_src emacs-lisp
  (require-package 'clojure-mode)

  (add-hook 'clojure-mode-hook
            (lambda ()
              (require-package 'cider)
              (cider-mode t)
              (local-set-key (kbd "RET") 'newline-and-indent)))
  (add-hook 'clojure-mode-hook 'origami-mode)
  (add-hook 'clojure-mode-hook 'aggressive-indent-mode)
  (add-hook 'clojure-mode-hook #'smartparens-strict-mode)
  (add-hook 'clojure-mode-hook #'subword-mode)

  (setq clojure-align-forms-automatically t)

  (after [cider]
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook #'subword-mode))
#+end_src

*** Sexp-fu

#+begin_src emacs-lisp
  (require-package 'cider-eval-sexp-fu)

#+end_src
* Ruby
#+begin_src emacs-lisp
  (require 'ruby-mode)

  (add-to-list 'auto-mode-alist '("Guardfile$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Rakefile\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Vagrantfile\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rake\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.rb\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.ru\\'" . ruby-mode))

  (add-hook 'ruby-mode 'superword-mode)

  (define-key ruby-mode-map (kbd "M-<down>") 'ruby-forward-sexp)
  (define-key ruby-mode-map (kbd "M-<up>") 'ruby-backward-sexp)
  (define-key ruby-mode-map (kbd "C-c C-e") 'ruby-send-region)

  (require-package 'inf-ruby)
  (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)

  (after 'ruby
    (require-package 'rubocop-mode)
    (add-hook 'ruby-mode-hook 'rubocop-mode)

    (require-package 'robe)
    (add-hook 'ruby-mode-hook 'robe-mode)

    (push 'company-robe company-backends))
#+end_src
* HTML

I find it depressingly humorous that I'm still authoring HTML by hand
in a lot of cases. I feel like someone told me this was going to be
automated at some point. Bleh.

#+begin_src emacs-lisp
  (require-package 'emmet-mode)
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode)
  (add-hook 'emmet-mode-hook (lambda () (setq emmet-move-cursor-between-quotes t)))
#+end_src
* Company

#+begin_src emacs-lisp
  (require-package 'company)

  (setq company-idle-delay 0.3)
  (setq company-minimum-prefix-length 1)
  (setq company-show-numbers t)
  (setq company-tooltip-limit 20)

  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case t)

  (setq company-dabbrev-code-everywhere t)
  (setq company-dabbrev-code-ignore-case t)

  (setq company-etags-ignore-case t)

  (setq company-global-modes
        '(not
          eshell-mode comint-mode text-mode erc-mode))

  (global-company-mode)

  (unless (face-attribute 'company-tooltip :background)
    (set-face-attribute 'company-tooltip nil :background "black" :foreground "gray40")
    (set-face-attribute 'company-tooltip-selection nil :inherit 'company-tooltip :background "gray15")
    (set-face-attribute 'company-preview nil :background "black")
    (set-face-attribute 'company-preview-common nil :inherit 'company-preview :foreground "gray40")
    (set-face-attribute 'company-scrollbar-bg nil :inherit 'company-tooltip :background "gray20")
    (set-face-attribute 'company-scrollbar-fg nil :background "gray40"))

  (require-package 'company-quickhelp)
  (company-quickhelp-mode 1)

#+end_src

* Dash
#+begin_src emacs-lisp
(require-package 'dash-at-point)

(global-set-key (kbd "C-c d") 'dash-at-point)
(global-set-key (kbd "C-c e") 'dash-at-point-with-docset)
#+end_src

* Elfeed
#+begin_src emacs-lisp
  (require-package 'elfeed-org)

  (elfeed-org)
  (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+end_src
* ERC
#+begin_src emacs-lisp
  (require 'erc)
  (require 'erc-log)
  (require 'erc-notify)
  (require 'erc-spelling)
  (require 'erc-autoaway)

  (setq erc-modules '(autoaway autojoin irccontrols log netsplit noncommands
                      notify pcomplete completion ring services stamp track
                      truncate))
  (after 'erc
    (setq erc-log-channels-directory (concat user-emacs-directory "erc/logs"))
    (setq erc-hide-list '("JOIN" "PART" "QUIT"))

    (setq erc-timestamp-only-if-changed-flag nil)
    (setq erc-timestamp-format "[%H:%M] ")
    (setq erc-insert-timestamp-function 'erc-insert-timestamp-left)
    (setq erc-kill-buffer-on-part t)
    (setq erc-kill-queries-on-quit t)
    (setq erc-kill-server-buffer-on-quit t)
    (setq erc-query-display 'buffer)
    (erc-track-mode t)
    (erc-completion-mode 1)
    (auto-fill-mode -1)
    (erc-ring-mode 1)
    (erc-log-mode 1)
    (erc-services-mode 1)
    (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                    "324" "329" "332" "333" "353" "477"))

    (setq erc-save-buffer-on-part t)
    (defadvice save-buffers-kill-emacs (before save-logs (arg) activate)
      (save-some-buffers t (lambda () (when (eq major-mode 'erc-mode) t))))

    (setq erc-truncate-mode t)

    (add-hook 'window-configuration-change-hook
              (lambda ()
                (setq erc-fill-column (- (window-width) 2)))))

#+end_src

* Flycheck
#+begin_src emacs-lisp
(require-package 'flycheck)

(setq flycheck-standard-error-navigation t)
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc html-tidy))

(add-hook 'after-init-hook #'global-flycheck-mode)

(when (display-graphic-p)
  (require-package 'flycheck-pos-tip)
  (setq flycheck-pos-tip-timeout -1)
  (flycheck-pos-tip-mode))

(defun /flycheck/advice/next-error-find-buffer (orig-func &rest args)
  (let* ((special-buffers
          (cl-loop for buffer in (mapcar #'window-buffer (window-list))
                   when (with-current-buffer buffer
                          (and
                           (eq (get major-mode 'mode-class) 'special)
                           (boundp 'next-error-function)))
                   collect buffer))
         (first-special-buffer (car special-buffers)))
    (if first-special-buffer
        first-special-buffer
      (apply orig-func args))))

(advice-add #'next-error-find-buffer :around #'/flycheck/advice/next-error-find-buffer)

#+end_src

* Ivy, counsel, & swiper
#+begin_src emacs-lisp
  (require-package 'ivy)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-virtual-abbreviate 'full)
  (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
  (setq ivy-height 16)
  (setq ivy-display-style 'fancy)
  (setq ivy-count-format "[%d/%d] ")
  (setq ivy-initial-inputs-alist nil)

  (require-package 'lv)
  (after 'lv
    (setq ivy-display-function
          (defun /ivy/display-function (text)
            (let ((lv-force-update t))
              (lv-message
               (if (string-match "\\`\n" text)
                   (substring text 1)
                 text))))))

  (require-package 'swiper)
  (after 'swiper
    (defadvice swiper (before dotemacs activate)
      (setq gc-cons-threshold most-positive-fixnum))
    (defadvice swiper-all (before dotemacs activate)
      (setq gc-cons-threshold most-positive-fixnum)))

  (require-package 'counsel)

  (global-set-key (kbd "C-x TAB") 'counsel-imenu)

  (after "projectile-autoloads"
    (require-package 'counsel-projectile))

  (defmacro /ivy/propertize (prefix face)
    `(lambda (str)
       (propertize str 'line-prefix ,prefix 'face ,face)))

  (defun /ivy/mini ()
    (interactive)
    (setq gc-cons-threshold most-positive-fixnum)
    (let* ((buffers (mapcar #'buffer-name (buffer-list)))
           (project-files
            (if (projectile-project-p)
                (mapcar (/ivy/propertize "[ project ] " 'ivy-virtual)
                        (projectile-current-project-files))
              nil))
           (bufnames (mapcar (/ivy/propertize "[ buffer ] " 'ivy-remote) buffers))
           (recents (mapcar (/ivy/propertize "[ recent ] " 'ivy-subdir) recentf-list)))
      (ivy-read "Search: " (append project-files bufnames recents)
                :action (lambda (f)
                          (with-ivy-window
                            (cond ((member f bufnames)
                                   (switch-to-buffer f))
                                  ((file-exists-p f)
                                   (find-file f))
                                  (t
                                   (find-file (concat (projectile-project-root) f)))))))))

  (counsel-mode t)
  (counsel-projectile-mode t)
  (ivy-mode t)

#+end_src

* Lisp

#+begin_src emacs-lisp
  (require-package 'elisp-slime-nav)
  (after 'elisp-slime-nav
    (defadvice elisp-slime-nav-find-elisp-thing-at-point (after dotemacs activate)
      (recenter)))

  ;; (require-package 'paredit)

  (defun /lisp/major-mode-hook ()
    (progn
      (elisp-slime-nav-mode)
      (eldoc-mode)
      (smartparens-strict-mode t)))

  (add-hook 'emacs-lisp-mode-hook #'/lisp/major-mode-hook)
  (add-hook 'lisp-interaction-mode-hook #'/lisp/major-mode-hook)
  (add-hook 'ielm-mode-hook #'/lisp/major-mode-hook)
#+end_src

* Misc
#+begin_src emacs-lisp
(require-package 'pcache)
(setq pcache-directory (concat user-emacs-directory "pcache/"))

(require-package 'request)
(setq request-storage-directory (concat user-emacs-directory "request/"))

(require-package 'wgrep)
(when (executable-find "ag")
  (require-package 'ag)
  (setq ag-highlight-search t)
  (setq ag-ignore-list dotemacs-globally-ignored-directories)
  (add-hook 'ag-mode-hook (lambda () (toggle-truncate-lines t)))
  (require-package 'wgrep-ag))

(require-package 'popwin)
(require 'popwin)
(popwin-mode)

(require-package 'aggressive-indent)
(require 'aggressive-indent)
(add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
(add-hook 'lisp-mode-hook #'aggressive-indent-mode)

(require-package 'browse-kill-ring)

#+end_src

* Navigation
#+begin_src emacs-lisp
  (require-package 'avy)

  (require-package 'ace-window)
  (global-set-key (kbd "C-x o") 'ace-window)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?o))
  (setq aw-background nil)
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0)))))

  (setq locate-command "mdfind") ;; MacOS Spotlight
  (global-set-key (kbd "C-c f l") 'locate)

  (defun locate-org-files (search-string)
    "Adjust `locate-with-filter' to only search `org-mode' files
    with SEARCH-STRING."
    (interactive "sSearch string: ")
    (locate-with-filter search-string ".org$"))
  (global-set-key (kbd "C-c f o") 'locate-org-files)

  (require-package 'visual-regexp)
  (require-package 'visual-regexp-steroids)
  (global-set-key (kbd "C-c r") 'vr/replace)
  (global-set-key (kbd "C-c q") 'vr/query-replace)

  (global-subword-mode 1)
  (global-set-key (kbd "M-]") 'next-buffer)
  (global-set-key (kbd "M-[") 'previous-buffer)
#+end_src

* PlantUML
#+begin_src emacs-lisp
  (require-package 'plantuml-mode)
#+end_src
* Org mode
#+begin_src emacs-lisp
  (after 'org
    (unless (file-exists-p org-directory)
      (make-directory org-directory))

    (setq org-catch-invisible-edits 'show-and-error)
    (setq org-cycle-separator-lines 0)

    (setq org-default-notes-file (expand-file-name (concat org-directory "/inbox.org")))
    (setq org-todo-keywords
          '((sequence "TODO" "INPROGRESS" "BLOCKED" "REVIEW" "|" "DONE" "ARCHIVED")))
    (setq org-todo-keyword-faces
          '(("TODO" . org-warning)
            ("INPROGRESS" . "yellow")
            ("BLOCKED" . "red")
            ("REVIEW" . "orange")
            ("DONE" . "green")
            ("ARCHIVED" . "blue")))
    (setq org-log-done t)
    (setq org-log-into-drawer t)

    (setq org-use-fast-todo-selection t)
    (setq org-treat-S-cursor-todo-selection-as-state-change nil)

    (setq org-capture-templates
          (quote (("t" "todo" entry (file "~/org/inbox.org")
                   "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                  ("j" "journal" entry (file+datetree "~/org/journal.org")
                   "**** %U%?%a \n" :tree-type week))))

    (setq org-refile-targets '((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))
    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)

    ;; Babel
    (setq org-babel-load-languages
          '((sh . t)
            (emacs-lisp . t)
            (ditaa . t)
            (plantuml . t)
            (sql . t)
            (clojure . t)))
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache   . "no")
            (:noweb   . "yes")
            (:hlines  . "no")
            (:tangle  . "no")
            (:padnewline . "yes")))
    (setq org-babel-clojure-backend 'cider)

    (after-load 'ob-ditaa
      (unless (and (boundp 'org-ditaa-jar-path)
                   (file-exists-p org-ditaa-jar-path))
        (let ((jar-name "ditaa0_9.jar")
              (url "http://jaist.dl.sourceforge.net/project/ditaa/ditaa/0.9/ditaa0_9.zip"))
          (setq org-ditaa-jar-path (expand-file-name jar-name (file-name-directory user-init-file)))
          (unless (file-exists-p org-ditaa-jar-path)
            (sanityinc/grab-ditaa url jar-name)))))

    (after-load 'ob-plantuml
      (let ((jar-name "plantuml.jar")
            (url "http://jaist.dl.sourceforge.net/project/plantuml/plantuml.jar"))
        (setq org-plantuml-jar-path (expand-file-name jar-name (file-name-directory
                                                                user-init-file)))
        (unless (file-exists-p org-plantuml-jar-path)
          (url-copy-file url org-plantuml-jar-path))))

    (when (boundp 'org-plantuml-jar-path)
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((plantuml . t))))

    (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)
    (org-clock-persistence-insinuate)

    (defun /org/org-mode-hook ()
      (toggle-truncate-lines t)
      (setq show-trailing-whitespace t)
      (turn-on-auto-fill)
      (add-hook 'before-save-hook
                'org-update-all-dblocks t t))
    (add-hook 'org-mode-hook #'/org/org-mode-hook)


    (require-package 'ob-async)
    (require 'ob-async)

    (require-package 'org-bullets)
    (add-hook 'org-mode-hook #'org-bullets-mode)

    (require-package 'org-trello)

    ;; UI
    (setq org-startup-indented t)
    (setq org-src-fontify-natively t)
    (setq org-pretty-entities t)
    (setq org-hide-emphasis-markers t)
    (setq org-fontify-whole-heading-line t)
    (setq org-fontify-done-headline t)
    (setq org-fontify-quote-and-verse-blocks t)
    (setq org-ellipsis "â€¦")
    (setq org-startup-align-all-tables t))
#+end_src

*** Todos
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO" "INPROGRESS" "BLOCKED" "REVIEW" "|" "DONE" "CANCELLED" "ARCHIVED")))

  (setq org-todo-keyword-faces
        '(("TODO" . org-warning)
          ("INPROGRESS" . "yellow")
          ("BLOCKED" . "red")
          ("REVIEW" . "orange")
          ("DONE" . "green")
          ("CANCELLED" . "gray35")
          ("ARCHIVED" . "blue")))
#+end_src
*** Agenda

#+begin_src emacs-lisp
  (setq org-agenda-files `(,org-directory))
  (setq org-refile-targets '((nil :maxlevel . 9)
                             (org-agenda-files :maxlevel . 9)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)

  ;; This section is ENTIRELY cribbed from https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html
  (defun /agenda/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

    PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (defun /agenda/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (defun /agenda/is-project-p ()
    "Any task with a todo keyword subtask."
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun /agenda/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (/agenda/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil))
          next-headline))))

  (setq org-agenda-custom-commands
        (quote (("c" todo "DONE|CANCELLED|ARCHIVED" nil)
                ("b" todo "BLOCKED" nil)
                ("p" "Today"
                 ((agenda "plain"
                          ((org-agenda-span 'day)))
                  (tags-todo "+PRIORITY=\"A\""
                             ((org-agenda-span 'day)
                              (org-agenda-overriding-header
                               "Priority tasks")))
                  (alltodo ""
                           ((org-agenda-skip-function
                             '(org-agenda-skip-if nil '(scheduled deadline)))
                            (org-agenda-overriding-header
                             "Low priority tasks")))))
                ("W" agenda "" ((org-agenda-ndays 21)))
("d" "Daily agenda and all TODOs"
           ((tags "PRIORITY=\"A\""
                  ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")))
            (agenda "" ((org-agenda-ndays 1)))
            (alltodo ""
                     ((org-agenda-skip-function '(or (/agenda/org-skip-subtree-if-habit)
                                                     (/agenda/org-skip-subtree-if-priority ?A)
                                                     (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-overriding-header "ALL normal priority tasks:"))))
           ((org-agenda-compact-blocks t)))

("h" "Habits" tags-todo "STYLE=\"habit\""
           ((org-agenda-overriding-header "Habits")
            (org-agenda-sorting-strategy
             '(todo-state-down effort-up category-keep))))

(" " "Agenda"
           ((agenda "" nil)
            (tags "REFILE"
                  ((org-agenda-overriding-header "Tasks to Refile")
                   (org-tags-match-list-sublevels nil)))

            (tags-todo "-CANCELLED/!"
                       ((org-agenda-overriding-header "Stuck Projects")
                        (org-agenda-skip-function '/agenda/skip-non-stuck-projects)
                        (org-agenda-sorting-strategy '(category-keep))))
            ))
                )))

#+end_src
*** Blogging

#+BEGIN_SRC emacs-lisp
  (require-package 'org2blog)
  (require 'auth-source)

  (let* ((credentials (auth-source-user-and-password "my-blog"))
         (username (nth 0 credentials))
         (password (nth 1 credentials))
         (config `(("my-blog"
                    :url "http://box2010.temp.domains/~atthewmn/xmlrpc.php"
                    :username ,username
                    :password ,password))))

    (setq org2blog/wp-blog-alist config))
#+END_SRC


* MacOS specifics

* LaTeX

Cribbed from
http://www.wangzerui.com/2017/02/20/setting-up-a-nice-environment-for-latex-on-macos/

#+begin_src emacs-lisp
  (require-package 'auctex-latexmk)

  (setq TeX-PDF-mode t)

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (push
               '("latexmk" "latexmk -pdf %s" TeX-run-TeX nil t
                 :help "Run latexmk on file")
               TeX-command-list)))
  (add-hook 'TeX-mode-hook (lambda () (setq TeX-command-default "latexmk")))

  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
  (setq TeX-view-program-list
        '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))

  (custom-set-variables
   '(TeX-source-correlate-method 'synctex)
   '(TeX-source-correlate-mode t)
   '(TeX-source-correlate-start-server t))
#+end_src
* MacOS specifics
#+begin_src emacs-lisp
  (defcustom dotemacs-os/additional-exec-paths
    nil
    "Additional paths to be added to `exec-path'."
    :type '(repeat (string))
    :group 'dotemacs)

  (require-package 'exec-path-from-shell)
  (exec-path-from-shell-initialize)

  (defun /os/addpath (patth)
    (let* ((directory (expand-file-name path))
           (env-value (concat directory path-separator (getenv "PATH"))))
      (when directory
        (setenv "PATH" env-value)
        (setq eshell-path-env env-value)
        (add-to-list 'exec-path directory))))

  (dolist (path dotemacs-os/additional-exec-paths)
    (/os/addpath path))

  (when (eq system-type 'darwin)
    (require-package 'osx-trash)
    (osx-trash-setup)

    (require-package 'reveal-in-osx-finder))

  (defun /os/reveal-in-os ()
    (interactive)
    (call-interactively #'reveal-in-osx-finder))
#+end_src

* Projectile
#+begin_src emacs-lisp
  (require-package 'projectile)

  (setq projectile-cache-file (concat user-emacs-directory "projectile.cache"))
  (setq projectile-known-projects-file
        (concat user-emacs-directory "projectile-bookmarks.eld"))
  (setq projectile-indexing-method 'alien)
  (setq projectile-enable-caching t)

  (setq projectile-completion-system 'ivy)

  (setq projectile-switch-project-action #'projectile-dired)
  (setq projectile-create-missing-test-files t)

  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

  (dolist (dir dotemacs-globally-ignored-directories)
    (add-to-list 'projectile-globally-ignored-directories dir))

  (dolist (file '(".DS_Store"))
    (add-to-list 'projectile-globally-ignored-files file))

  (cond
   ((executable-find "ag")
    (setq projectile-generic-command
          (concat "ag -0 -l --nocolor"
                  (mapconcat #'identity (cons "" projectile-globally-ignored-directories) " --ignore-dir="))))
   ((executable-find "ack")
    (setq projectile-generic-command
          (concat "ack -f --print0"
                  (mapconcat #'identity (cons "" projectile-globally-ignored-directories) " --ignore-dir=")))))
#+end_src

* Flyspell

This needs some more massaging I think.

#+begin_src emacs-lisp
  (when (or (executable-find "aspell")
            (executable-find "ispell")
            (executable-find "hunspell"))
    (eval-when-compile (require 'cl))
    (add-hook 'after-change-major-mode-hook
              (lambda ()
                (when (cl-find-if #'derived-mode-p '(text-mode org-mode))
                  (turn-on-flyspell)))))

  (dolist (mode '(emacs-lisp-mode-hook
                  inferior-lisp-mode-hook
                  clojure-mode-hook))
    (add-hook mode '(lambda ()
                      (flyspell-prog-mode))))

  (global-set-key (kbd "<f8>") 'ispell-word)
  (defun /spell/flyspell-check-next-highlighted-word ()
    "Custom function to spell check next highlighted word."
    (interactive)
    (flyspell-goto-next-error)
    (ispell-word))
  (global-set-key (kbd "M-<f8>") '/spell/flyspell-check-next-highlighted-word)

  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  (when (executable-find "aspell")
    (setq-default ispell-program-name "aspell")
    (setq ispell-really-aspell t))

#+end_src

*** Langtool

#+begin_src emacs-lisp
  (require-package 'langtool)


  (defvar languagetool-download-dir (concat user-emacs-directory "downloads"))
  (defvar languagetool-home-dir (file-name-as-directory (expand-file-name "LanguageTool" user-emacs-directory)))

  (setq langtool-language-tool-jar (or (locate-file "languagetool-commandline.jar" languagetool-home-dir)
                                       (expand-file-name "languagetool-commandline.jar" languagetool-home-dir))
        langtool-mother-tongue "en")

  (unless (file-exists-p langtool-language-tool-jar)
    (url-copy-file
     "https://www.languagetool.org/download/LanguageTool-stable.zip"
     (expand-file-name "LanguageTool-stable.zip" languagetool-download-dir) t)

    (require 'dired-aux)

    (dired-compress-file (expand-file-name "LanguageTool-stable.zip" languagetool-download-dir))

    (let* ((langtool-versioned-name (car (last
                                          (directory-files (expand-file-name "LanguageTool-stable" languagetool-download-dir)))))
           (langtool-dir-name (expand-file-name
                               langtool-versioned-name
                               (concat languagetool-download-dir "/LanguageTool-stable/")))
           (langtool-dir (file-name-as-directory langtool-dir-name)))
      (copy-directory
       langtool-dir
       (expand-file-name "LanguageTool" user-emacs-directory)
       nil t t)
      (delete-directory
       (file-name-as-directory (expand-file-name "LanguageTool-stable" languagetool-download-dir)) t)))
#+end_src

* Prodigy (Manage external services)

This isn't working currently.

#+begin_src emacs-lisp
  (require-package 'prodigy)

  (defface prodigy-dull-face
    '((((class color)) :foreground "#999999"))
    "Gray color indicating waiting."
    :group 'prodigy)

  (prodigy-define-status :id 'running 'prodigy-dull-face)
  (prodigy-define-status :id 'exception :face 'prodigy-red-face)

  (prodigy-define-tag
    :name 'ring
    :on-output (lambda (service output)
                 (when (s-matches? "Started server on port" output)
                   (prodigy-set-status service 'ready))
                 (when (s-matches? "Exception" output)
                   (prodigy-set-status service 'exception))))

  (prodigy-define-service
    :name "vms-composer-datomic-socks"
    :cwd "~/Workspace/consulting/village-music-school/systems/composer/"
    :command "bash"
    :args '("~/Downloads/datomic-socks-proxy" "-r" "us-east-1" "vms-scheduler"))

  (prodigy-define-service
    :name "vms-composer-repl"
    :cwd "~/Workspace/consulting/village-music-school/systems/composer/"
    :command "clojure"
    :args '("-A:test:dev:deps" "-Sdeps" "'{:deps {nrepl {:mvn/version \"0.5.0\"} cider/cider-nrepl {:mvn/version \"0.19.0\"}}}'" "-m" "nrepl.cmdline" "--middleware" "[cider.nrepl/cider-middleware]"))
#+end_src
* Utility Functions
#+begin_src emacs-lisp
  (defun /utils/window-killer ()
    "Closes the window, and deletes the buffer if it's the last window open."
    (interactive)
    (if (> buffer-display-count 1)
        (if (= (length (window-list)) 1)
            (kill-buffer)
          (delete-window))
      (kill-buffer-and-window)))

  (defun /utils/minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is actie, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (defun /utils/google ()
    "Google the selected region if any, display a query prompt otherwise."
    (interactive)
    (browse-url
     (concat
      "https://www.google.com/search?ie=utf-8&oe=utf-8&q="
      (url-hexify-string (if mark-active
                             (buffer-substring (region-beginning) (region-end))
                           (read-string "Search Google: "))))))

  (defun /utils/eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (preceding-sexp))))
      (backward-kill-sexp)
      (insert (format "%s" value))))

  (defun /utils/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))

  (defun /utils/delete-current-buffer-file ()
    "Kill the current buffer and deletes the file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (if (vc-backend filename)
            (vc-delete-file filename)
          (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
            (delete-file filename)
            (message "Deleted file %s" filename)
            (kill-buffer))))))

  (defun /utils/goto-scratch-buffer ()
    "Create a new scratch buffer."
    (interactive)
    (switch-to-buffer (get-buffer-create "*scratch*")))

  (defun /utils/insert-last-kbd-macro ()
    (interactive)
    (name-last-kbd-macro 'my-last-macro)
    (insert-kbd-macro 'my-last-macro))

  (defun /utils/set-buffer-to-unix-format ()
    "Converts the current buffer to UNIX file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix nil))

  (defun /utils/set-buffer-to-dos-format ()
    "Converts the current buffer to DOS file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun /utils/find-file-as-root (file)
    "Edits a file as root."
    (interactive "f")
    (find-file-other-window (concat "/sudo:root@localhost:" file)))

  (defun /utils/untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun /utils/indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun /utils/cleanup-buffer ()
    (interactive)
    (/utils/untabify-buffer)
    (delete-trailing-whitespace)
    (/utils/indent-buffer))
#+end_src

* VCS
#+begin_src emacs-lisp
(setq vc-make-backup-files t)

(when (executable-find "git")
  (require-package 'magit)
  (require-package 'forge)

  (defun /vcs/magit-post-display-buffer-hook ()
    (if (string-match "*magit:" (buffer-name))
        (delete-other-windows)))
  (add-hook 'magit-post-display-buffer-hook #'/vcs/magit-post-display-buffer-hook)

  (setq magit-section-show-child-count t)
  (setq magit-diff-arguments '("--histogram"))
  (setq magit-ediff-dwim-show-on-hunks t)
  (setq magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)

  (after 'eshell
    (require-package 'pcmpl-git)
    (require 'pcmpl-git))

  (if (display-graphic-p)
      (progn
        (require-package 'git-gutter-fringe+)
        (require 'git-gutter-fringe+))
    (require-package 'git-gutter+))
  (global-git-gutter+-mode))

(require-package 'diff-hl)
(add-hook 'dired-mode-hook 'diff-hl-dired-mode)
(unless (display-graphic-p)
  (diff-hl-margin-mode))
(if (package-installed-p 'magit)
    (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))

(require-package 'with-editor)
(autoload 'with-editor-export-editor "with-editor")
(defun /vcs/with-editor-export ()
  (unless (equal (buffer-name) "*fzf*")
    (with-editor-export-editor)
    (message "")))
(add-hook 'shell-mode-hook #'/vcs/with-editor-export)
(add-hook 'term-exec-hook #'/vcs/with-editor-export)
(add-hook 'eshell-mode-hook #'/vcs/with-editor-export)

(/boot/lazy-major-mode "^\\.gitignore$" gitignore-mode)
(/boot/lazy-major-mode "^\\.gitattributes$" gitattributes-mode)

#+end_src

* Eshell

It is a long standing goal of mine to switch to eshell entirely.
Unfortunately, =bash= is required for some critical things like the
SOCKS proxy script for connecting to datomic cloud. Maybe one day
soon, though.

#+begin_src emacs-lisp
  (setq eshell-history-size nil)

  (defun if-string-match-then-result (to-match pairs)
    "Takes a string to match and a list of pairs, the first element
  of the pairs is a regexp to test against the string, the second of
  which is a return value if it matches."
    (catch 'break
      (dolist (val pairs)
        (if (string-match-p (car val) to-match)
            (progn
              (throw 'break (cadr val)))))
      (throw 'break nil)))

  (defun eshell/extract (file)
    (eshell-command-result (concat (if-string-match-then-result
                                    file
                                    '((".*\.tar.bz2" "tar xjf")
                                      (".*\.tar.gz" "tar xzf")
                                      (".*\.bz2" "bunzip2")
                                      (".*\.rar" "unrar x")
                                      (".*\.gz" "gunzip")
                                      (".*\.tar" "tar xf")
                                      (".*\.tbz2" "tar xjf")
                                      (".*\.tgz" "tar xzf")
                                      (".*\.zip" "unzip")
                                      (".*\.jar" "unzip")
                                      (".*\.Z" "uncompress")
                                      (".*" "echo 'Could not extract the requested file:'")))
                                   " " file)))

  (defun eshell/clear ()
    "Clear the eshell buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)))

  (defun eshell/take (dir)
    "Make a directory and cd into it."
    (interactive)
    (eshell/mkdir "-p" dir)
    (eshell/cd dir))
#+end_src
* File-local Variables
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
